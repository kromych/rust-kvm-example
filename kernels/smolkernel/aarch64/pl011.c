#include "pl011.h"

/*
    PL011 Registers:

    Offset  Name              Type Reset        Bits    Description
    ----------------------------------------------------------------------
    0x000   UARTDR            RW   0x---        12/8    Data Register
    0x004   UARTRSR/UARTECR   RW   0x0          4/0     Receive Status Register/Error Clear Register
    0x018   UARTFR            RO   0b-10010---  9       Flag Register
    0x020   UARTILPR          RW   0x00         8       IrDA Low-Power Counter Register
    0x024   UARTIBRD          RW   0x0000       16      Integer Baud Rate Register
    0x028   UARTFBRD          RW   0x00         6       Fractional Baud Rate Register
    0x02C   UARTLCR_H         RW   0x00         8       Line Control Register
    0x030   UARTCR            RW   0x0300       16      Control Register
    0x034   UARTIFLS          RW   0x12         6       Interrupt FIFO Level Select Register
    0x038   UARTIMSC          RW   0x000        11      Interrupt Mask Set/Clear Register
    0x03C   UARTRIS           RO   0x00-        11      Raw Interrupt Status Register
    0x040   UARTMIS           RO   0x00-        11      Masked Interrupt Status Register
    0x044   UARTICR           WO   -            11      Interrupt Clear Register
    0x048   UARTDMACR         RW   0x00         3       DMA Control Register
    0xFE0   UARTPeriphID0     RO   0x11         8       UARTPeriphID0 Register
    0xFE4   UARTPeriphID1     RO   0x10         8       UARTPeriphID1 Register
    0xFE8   UARTPeriphID2     RO   0x_4a        8       UARTPeriphID2 Register
    0xFEC   UARTPeriphID3     RO   0x00         8       UARTPeriphID3 Register
    0xFF0   UARTPCellID0      RO   0x0D         8       UARTPCellID0 Register
    0xFF4   UARTPCellID1      RO   0xF0         8       UARTPCellID1 Register
    0xFF8   UARTPCellID2      RO   0x05         8       UARTPCellID2 Register
    0xFFC   UARTPCellID3      RO   0xB1         8       UARTPCellID3 Register
*/

#define UARTDR          0x000UL
#define UARTRSR         0x004UL
#define UARTECR         0x004UL
#define UARTFR          0x018UL
#define UARTIBRD        0x024UL
#define UARTFBRD        0x028UL
#define UARTLCR_H       0x02cUL
#define UARTCR          0x030UL
#define UARTIMSC        0x038UL
#define UARTICR         0x044UL
#define UARTDMACR       0x048UL

#define UARTPeriphID0   0xFE0UL
#define UARTPeriphID1   0xFE4UL
#define UARTPeriphID2   0xFE8UL
#define UARTPeriphID3   0xFECUL
#define UARTPCellID0    0xFF0UL
#define UARTPCellID1    0xFF4UL
#define UARTPCellID2    0xFF8UL
#define UARTPCellID3    0xFFCUL

#define UARTCR_RX_ENABLE    (1UL << 9)
#define UARTCR_TX_ENABLE    (1UL << 8)
#define UARTCR_UART_ENABLE  (1UL)

#define UARTLCR_H_FIFO_EN   (1UL << 4)
#define UARTLCR_H_8BITS     (3UL << 5)

#define UARTFR_TX_EMPTY    (1UL << 7)
#define UARTFR_RX_EMPTY    (1UL << 4)
#define UARTFR_UART_BUSY   (1UL << 3)

static uint32_t pl011_read(const struct pl011_t *pl011, uint32_t offset)
{
    return *((volatile uint32_t*)(pl011->base_addr + offset));
}

static uint32_t pl011_write(const struct pl011_t *pl011, uint32_t offset, uint32_t value)
{
    *((volatile uint32_t*)(pl011->base_addr + offset)) = value;
}

void pl011_init(struct pl011_t *pl011)
{
    uint64_t id = 0;

    // Read identification registers
    id |= pl011_read(pl011, UARTPeriphID0) & 0xff; id <<= 8;
    id |= pl011_read(pl011, UARTPeriphID1) & 0xff; id <<= 8;
    id |= pl011_read(pl011, UARTPeriphID2) & 0xff; id <<= 8;
    id |= pl011_read(pl011, UARTPeriphID3) & 0xff; id <<= 8;
    id |= pl011_read(pl011, UARTPCellID0) & 0xff; id <<= 8;
    id |= pl011_read(pl011, UARTPCellID1) & 0xff; id <<= 8;
    id |= pl011_read(pl011, UARTPCellID2) & 0xff; id <<= 8;
    id |= pl011_read(pl011, UARTPCellID3) & 0xff;
    pl011->id = id;

    // Mask interrupts
    pl011_write(pl011, UARTIMSC, 0x000);
    // Disable interrupts (lower 10 bits)
    pl011_write(pl011, UARTICR, 0x3ff);
    // Disable DMA on Rx and Tx
    pl011_write(pl011, UARTDMACR, 0x0);

    // Leave Rx and Tx enabled to drain FIFOs, wait a bit, 
    // and then disable Rx, Tx, and UART.
    pl011_write(pl011, UARTCR, UARTCR_RX_ENABLE | UARTCR_TX_ENABLE);
    pl011_read(pl011, UARTCR);
    pl011_read(pl011, UARTCR);
    pl011_write(pl011, UARTCR, 0x00000000);

    // Set integer and fractinal parts of the baud rate,
    // harcoded for now
    pl011_write(pl011, UARTFBRD, 0x00000004);
    pl011_write(pl011, UARTIBRD, 0x00000027);
    // The UARTLCR_H, UARTIBRD, and UARTFBRD registers form the single 30-bit 
    // wide UARTLCR Register that is updated on a single write strobe generated by a 
    // UARTLCR_H write
    pl011_write(pl011, UARTLCR_H, UARTLCR_H_FIFO_EN | UARTLCR_H_8BITS);

    // Enable Tx and Rx, wait a bit, and then enable UART
    pl011_write(pl011, UARTCR, UARTCR_RX_ENABLE | UARTCR_TX_ENABLE);
    pl011_read(pl011, UARTCR);
    pl011_read(pl011, UARTCR);
    pl011_write(pl011, UARTCR, UARTCR_RX_ENABLE | UARTCR_TX_ENABLE | UARTCR_UART_ENABLE);
}

void pl011_send_byte(const struct pl011_t *pl011, char data)
{
    while (pl011_read(pl011, UARTFR) != (UARTFR_TX_EMPTY | UARTFR_RX_EMPTY))
    {
        // Spin here
    }
    pl011_write(pl011, UARTDR, data);
}
